import { QnA } from "../../types";

const etcQuestions: QnA[] = [
  {
    question:
      "모던 프론트엔드 개발 환경에서 자주 사용되는 도구들과 그 역할을 설명해주세요.",
    answer:
      "모던 프론트엔드 개발 환경에서는 다양한 도구들이 사용됩니다. 패키지 매니저로는 npm, yarn, pnpm이 있으며, 각각의 장단점을 고려하여 선택합니다. 번들러로는 Webpack, Vite, Rollup 등이 사용되며, 코드 최적화와 모듈 번들링을 담당합니다. 코드 품질 관리 도구로는 ESLint와 Prettier가 사용되며, 각각 코드 품질 검사와 포맷팅을 담당합니다. 테스트 도구로는 Jest, React Testing Library, Cypress 등이 사용되며, 단위 테스트부터 E2E 테스트까지 다양한 테스트를 수행합니다. 또한 Husky와 lint-staged를 통해 Git 훅을 관리하고, GitHub Actions나 Jenkins를 통해 CI/CD 파이프라인을 구성하여 개발 프로세스를 자동화합니다.",
  },
  {
    question:
      "패키지 매니저(npm, yarn, pnpm)의 차이점과 각각의 특징을 설명해주세요.",
    answer:
      "npm은 Node.js의 기본 패키지 매니저로, package-lock.json을 통해 의존성을 관리하며, npm@7부터 workspaces를 지원합니다. yarn은 Facebook이 개발한 패키지 매니저로, 병렬 설치를 통해 npm보다 빠른 설치 속도를 제공하며, yarn.lock을 통해 의존성을 관리합니다. 또한 Plug'n'Play 기능을 통해 node_modules 없이 의존성을 관리할 수 있습니다. pnpm은 가장 최근에 등장한 패키지 매니저로, 하드 링크를 통해 디스크 공간을 효율적으로 사용하며, 엄격한 의존성 관리로 유령 의존성 문제를 해결합니다. 또한 모노레포 지원이 우수하고, 설치 속도가 가장 빠르다는 특징이 있습니다. 각 패키지 매니저는 lockfile을 통해 의존성 버전을 고정하여 일관된 개발 환경을 제공하며, 보안 취약점 검사 기능도 제공합니다.",
  },
  {
    question:
      "모노레포(Monorepo) 아키텍처의 장단점과 주요 도구들을 설명해주세요.",
    answer:
      "모노레포는 여러 프로젝트를 단일 저장소에서 관리하는 방식입니다. 장점으로는 1) 코드 공유와 재사용 용이, 2) 의존성 관리 단순화, 3) 원자적 커밋과 리팩토링 용이성, 4) 통합 CI/CD 구성 가능이 있습니다. 단점으로는 1) 저장소 크기 증가, 2) 빌드/테스트 시간 증가, 3) 접근 권한 관리 복잡성이 있습니다. 주요 도구로는 Nx(React 생태계 특화), Turborepo(Next.js 통합), Lerna(npm 패키지 관리), Yarn/Npm Workspaces(기본 모노레포 지원), pnpm(효율적인 의존성 관리) 등이 있습니다.",
  },
  {
    question: "모노레포에서의 의존성 관리와 빌드 최적화 방법을 설명해주세요.",
    answer:
      "모노레포의 의존성 관리는 1) Yarn/Npm/pnpm Workspaces를 통한 중앙화된 의존성 관리, 2) 공유 의존성 호이스팅으로 디스크 공간 절약, 3) 패키지 간 로컬 의존성 관리가 핵심입니다. 빌드 최적화는 1) 캐싱(Turborepo의 Remote Caching, Nx의 Computation Caching), 2) 영향받은 프로젝트만 선택적 빌드(Affected Commands), 3) 병렬 실행, 4) 증분 빌드 지원 등을 통해 이루어집니다. 또한 TypeScript Project References를 활용한 타입 체킹 최적화도 중요합니다.",
  },
  {
    question: "모노레포에서의 테스트 전략과 CI/CD 구성 방법을 설명해주세요.",
    answer:
      "모노레포의 테스트 전략은 1) 공유 컴포넌트/유틸리티의 단위 테스트, 2) 각 애플리케이션의 통합 테스트, 3) E2E 테스트의 계층적 구조로 구성됩니다. CI/CD는 1) 변경된 프로젝트만 선택적으로 테스트/배포(GitHub Actions의 변경 감지), 2) 캐시를 활용한 빌드 최적화, 3) 병렬 작업 실행, 4) 환경별 배포 파이프라인 구성이 중요합니다. Nx Cloud나 Turborepo의 Remote Caching을 활용하여 CI 성능을 최적화할 수 있습니다.",
  },
  {
    question: "모노레포에서의 버전 관리와 릴리스 프로세스를 설명해주세요.",
    answer:
      "모노레포의 버전 관리는 1) Conventional Commits를 통한 변경사항 추적, 2) Lerna나 Changesets를 사용한 자동 버전 관리, 3) 패키지 간 의존성을 고려한 버전 범프가 핵심입니다. 릴리스 프로세스는 1) 변경사항 감지 및 버전 업데이트, 2) CHANGELOG 자동 생성, 3) Git 태그 생성, 4) npm 패키지 배포, 5) 애플리케이션 배포의 단계로 이루어집니다. 이때 Fixed/Independent 버전 관리 전략 중 선택할 수 있습니다.",
  },
  {
    question:
      "프론트엔드 프로젝트의 성능 최적화 도구와 모니터링 방법을 설명해주세요.",
    answer:
      "프론트엔드 프로젝트의 성능 최적화를 위해 Lighthouse를 사용하여 웹 성능, 접근성, SEO 등을 분석하고, Chrome DevTools의 Performance 탭을 통해 런타임 성능을 측정합니다. webpack-bundle-analyzer나 rollup-plugin-visualizer를 통해 번들 크기를 분석하고 최적화할 수 있으며, Core Web Vitals를 모니터링하여 실제 사용자 경험을 측정합니다. 에러 추적을 위해 Sentry나 LogRocket을 사용하고, Google Analytics를 통해 사용자 행동을 분석합니다. 이미지 최적화를 위해 next/image나 sharp 같은 도구를 사용하며, 서비스 워커를 통해 오프라인 지원과 캐싱 전략을 구현합니다. 또한 New Relic이나 DataDog 같은 APM 도구를 통해 애플리케이션의 전반적인 성능을 모니터링할 수 있습니다.",
  },
  {
    question: "마이크로서비스 아키텍처(MSA)의 특징과 장단점을 설명해주세요.",
    answer:
      "마이크로서비스 아키텍처는 하나의 큰 애플리케이션을 여러 개의 독립적인 서비스로 분리하여 개발하는 방식입니다. 주요 특징으로는 1) 서비스별 독립적인 개발, 배포, 확장 가능, 2) 각 서비스가 자체 데이터베이스를 가짐, 3) API를 통한 서비스 간 통신, 4) 폴리글랏 아키텍처 지원이 있습니다. 장점으로는 서비스별 독립적인 스케일링, 빠른 배포와 롤백, 기술 스택 자유도 증가, 장애 격리가 있으며, 단점으로는 분산 시스템의 복잡성, 서비스 간 통신 오버헤드, 데이터 일관성 관리의 어려움, 모니터링과 디버깅의 복잡성이 있습니다.",
  },
  {
    question:
      "MSA에서의 서비스 간 통신 방식과 API Gateway의 역할을 설명해주세요.",
    answer:
      "MSA에서 서비스 간 통신은 크게 동기 통신(REST, gRPC)과 비동기 통신(메시지 큐, 이벤트 버스)으로 나눌 수 있습니다. API Gateway는 클라이언트와 마이크로서비스 사이의 중간 계층으로, 1) 요청 라우팅과 로드 밸런싱, 2) 인증/인가 처리, 3) 요청/응답 변환, 4) 속도 제한과 캐싱, 5) 서비스 디스커버리, 6) 모니터링과 로깅 등의 역할을 수행합니다. Netflix Zuul, Kong, AWS API Gateway 등이 대표적인 도구입니다.",
  },
  {
    question: "MSA에서의 데이터 일관성과 트랜잭션 관리 방법을 설명해주세요.",
    answer:
      "MSA에서는 각 서비스가 독립적인 데이터베이스를 가지므로, 분산 트랜잭션 관리가 중요합니다. SAGA 패턴을 사용하여 장기 트랜잭션을 관리하며, 이는 보상 트랜잭션을 통해 일관성을 유지합니다. 이벤트 소싱 패턴을 통해 상태 변화를 이벤트로 저장하고 추적할 수 있으며, CQRS 패턴을 통해 읽기와 쓰기 모델을 분리하여 성능과 확장성을 개선할 수 있습니다. 최종 일관성(Eventual Consistency) 모델을 채택하여 일시적인 데이터 불일치를 허용하면서 시스템의 가용성을 높입니다.",
  },
  {
    question: "MSA에서의 서비스 디스커버리와 로드 밸런싱에 대해 설명해주세요.",
    answer:
      "서비스 디스커버리는 동적으로 변화하는 마이크로서비스의 위치(IP, 포트)를 찾는 메커니즘입니다. Netflix Eureka, Consul, etcd 등의 도구를 사용하여 구현하며, 서비스 등록과 검색을 자동화합니다. 로드 밸런싱은 클라이언트 사이드(Ribbon)와 서버 사이드(Nginx, HAProxy) 방식으로 나뉘며, 서비스 인스턴스 간의 부하를 분산합니다. 헬스 체크를 통해 장애 인스턴스를 감지하고 자동으로 트래픽을 재라우팅하며, 서킷 브레이커 패턴을 통해 장애 전파를 방지합니다.",
  },
  {
    question:
      "번들러(Webpack, Vite, Rollup)의 차이점과 각각의 사용 사례를 설명해주세요.",
    answer:
      "Webpack은 가장 성숙한 번들러로, 풍부한 생태계와 다양한 로더, 플러그인을 제공하며, Code Splitting, HMR 등의 고급 기능을 지원합니다. 복잡한 애플리케이션의 번들링에 적합하며, Create React App 등 많은 프로젝트에서 기본 번들러로 사용됩니다. Vite는 ES 모듈을 기반으로 한 차세대 번들러로, 개발 서버 구동 시간과 HMR 속도가 매우 빠르며, 프로덕션 빌드 시에는 Rollup을 사용합니다. 특히 모던 브라우저를 타겟으로 하는 프로젝트에 적합합니다. Rollup은 라이브러리 개발에 최적화된 번들러로, Tree Shaking이 뛰어나고 더 작은 번들 크기를 제공하며, ESM 포맷의 출력에 강점이 있습니다.",
  },
  {
    question:
      "ESLint와 Prettier의 역할과 차이점, 그리고 함께 사용하는 방법을 설명해주세요.",
    answer:
      "ESLint는 JavaScript/TypeScript 코드의 품질을 검사하는 정적 분석 도구로, 잠재적인 버그와 안티 패턴을 찾아내고, 일관된 코딩 스타일을 강제할 수 있습니다. .eslintrc 파일을 통해 규칙을 상세하게 구성할 수 있으며, 자동 수정 기능도 제공합니다. Prettier는 코드 포맷터로, 일관된 코드 스타일을 자동으로 적용하며, 들여쓰기, 줄 바꿈, 따옴표 등을 정해진 규칙에 따라 변환합니다. .prettierrc 파일로 옵션을 설정할 수 있으며, 최소한의 설정으로 강력한 포맷팅을 제공합니다. 두 도구를 함께 사용할 때는 eslint-config-prettier로 충돌을 방지하고, eslint-plugin-prettier로 Prettier 규칙을 ESLint에 통합하며, VSCode 확장 프로그램과 함께 사용하여 저장 시 자동 포맷팅을 구현할 수 있습니다.",
  },
  {
    question:
      "Git Hook과 lint-staged를 활용한 코드 품질 관리 방법을 설명해주세요.",
    answer:
      "Git Hook은 Git 작업 과정의 특정 시점에 자동으로 실행되는 스크립트로, Husky를 사용하여 쉽게 설정할 수 있습니다. pre-commit, pre-push 등의 훅을 통해 커밋이나 푸시 전에 코드 검사를 수행할 수 있습니다. lint-staged는 Git의 Staged 상태에 있는 파일들만 선택적으로 린트 검사를 수행하는 도구로, 전체 프로젝트가 아닌 변경된 파일만 검사하여 성능을 최적화합니다. package.json이나 .lintstagedrc 파일에서 파일 패턴별로 실행할 명령어를 설정할 수 있으며, ESLint, Prettier, Jest 등 다양한 도구와 함께 사용할 수 있습니다. 이를 통해 일관된 코드 품질을 유지하고, 문제가 있는 코드가 저장소에 들어가는 것을 방지할 수 있습니다.",
  },
];

export default etcQuestions;
